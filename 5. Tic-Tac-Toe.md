# Tic-Tac-Toe

이번 가이드는 Move로 3X3 보드의 tic-tac-toe를 만드는 과정을 소개합니다. 이 예제는 4. Distributed-Counter 과정을 먼저 수행한 분들을 대상으로 합니다. 앞선 내용과 중복되는 부분은 생략했으니, 처음 진행하시는 분들은 먼저 해당 예제를 학습하시기를 권장합니다.

## 1단계: 프로젝트 폴더 생성

새로운 폴더를 생성하여 이동합니다.

```bash
mkdir tic-tac-toe && cd tic-tac-toe
```

이 폴더는 프로젝트의 모든 파일을 담는 최상위 폴더입니다.
원하는 다른 이름으로 바꿔도 되지만, 이후 가이드에서는 이 구조를 기준으로 설명합니다.

## 2단계: Move 디렉토리 생성

```bash
mkdir -p ./move/tic-tac-toe/sources
```

`sources` 폴더에 move 코드가 작성될 것입니다.

## 3단계: Smart Contracts 작성

### 3-1: toml 파일 작성

스마트 컨트랙트를 작성하기 시작하려면, `tic-tac-toe/move` 안에 `Move.toml` 파일을 생성하고, 다음 코드를 복사하여 붙여넣습니다.

```bash
[package]
name = "tic_tac_toe"
edition = "2024.beta"

[dependencies]
[addresses]
tic_tac_toe = "0x0"
```

`Move.toml`은 Move 패키지의 매니페스트 파일로, Move 모듈을 구성하고 관리하는 정보를 담고 있습니다. 각 요소의 자세한 정보는 `4. Distributed-Counter.md`dml `3-1`을 확인하세요.

### 3-2 `owned.move` 파일 생성 및 `module` 정의

tic-tac-toe/move/counter/sources 안에 `owned.move` 파일을 생성합니다.
파일 안에 아래 코드를 작성합니다.

```rust
module tic_tac_toe::owned;
```

### 3-3 `use` 작성

use는 다른 모듈에서 정의된 기능(함수, struct, constant 등)을 현재 모듈 안으로 가져오는 키워드입니다.

```rust
use sui::event;
use sui::transfer::Receiving;
```

### `sui::event`

- 이벤트를 발생시킬 때 사용하는 기능들을 제공합니다.
- 스마트 컨트랙트 실행 중 중요한 상태 변화를 기록하거나, 프론트엔드/오프체인 서비스에서 모니터링할 수 있도록 신호를 남길 때 사용합니다.

### `sui::transfer::Receiving`

- 해당 트랜잭션에서 수신될 수 있는 Move 객체입니다.

### 3-4 object type 정의

```rust
// === Object Types ===

/// The state of an active game of tic-tac-toe.
public struct Game has key, store {
    id: UID,
    /// Marks on the board.
    board: vector<u8>,
    /// The next turn to be played.
    turn: u8,
    /// The address expected to send moves on behalf of X.
    x: address,
    /// The address expected to send moves on behalf of O.
    o: address,
    /// Public key of the admin address.
    admin: vector<u8>,
}

/// The player that the next turn is expected from is given a `TurnCap`.
public struct TurnCap has key {
    id: UID,
    game: ID,
}

/// A request to make a play -- only the player with the `TurnCap` can
/// create and send `Mark`s.
public struct Mark has key, store {
    id: UID,
    player: address,
    row: u8,
    col: u8,
}

/// An NFT representing a finished game. Sent to the winning player if there
/// is one, or to both players in the case of a draw.
public struct Trophy has key {
    id: UID,
    /// Whether the game was won or drawn.
    status: u8,
    /// The state of the board at the end of the game.
    board: vector<u8>,
    /// The number of turns played
    turn: u8,
    /// The other player (relative to the player who owns this Trophy).
    other: address,
}
```

### `vector<u8>`

- vector<T>는 Move에서 제공하는 가변 길이 배열(list) 타입입니다.
- 여기서 T는 원소의 타입을 뜻하고, u8은 8비트 부호 없는 정수(0~255)를 의미합니다.
- 따라서 vector<u8>은 바이트 배열(byte array)을 표현한다고 보면 됩니다.
-

### `game: ID`

- ID는 Move에서 객체(Object)의 고유 식별자를 나타내는 타입입니다.
- 어떤 Game 객체에 연결된 턴 권한인지를 가리키는 역할입니다.

### 3-5 event types와 constants

```rust
// === Event Types ===

public struct MarkSent has copy, drop {
    game: ID,
    mark: ID,
}

public struct GameEnd has copy, drop {
    game: ID,
}

// === Constants ===

// Marks
const MARK__: u8 = 0;
const MARK_X: u8 = 1;
const MARK_O: u8 = 2;

// Trophy status
const TROPHY_NONE: u8 = 0;
const TROPHY_DRAW: u8 = 1;
const TROPHY_WIN: u8 = 2;
```

### event type

- Sui Move에서는 `event::emit<T>(&event)`을 통해 체인에 기록되는 로그를 남길 수 있습니다.
- 이때 T는 보통 struct로 정의된 이벤트 타입입니다.
- 이 타입은 체인에서 직접 소유되거나 조작할 수는 없습니다.

### 3-6 에러 정의

```rust
// === Errors ===

#[error]
const EInvalidLocation: vector<u8> = b"Move was for a position that doesn't exist on the board";

#[error]
const EWrongPlayer: vector<u8> = b"Game expected a move from another player";

#[error]
const ENotFinished: vector<u8> = b"Game has not reached an end condition";

#[error]
const EAlreadyFinished: vector<u8> = b"Can't place a mark on a finished game";

#[error]
const EInvalidEndState: vector<u8> = b"Game reached an end state that wasn't expected";
```

### [error]

- 이 상수를 Move 에러 코드(error constant)로 지정합니다.
- `b"..."` 구문은 문자열을 바이트 배열로 변환합니다.

### 3-7 private helper 함수 정의

```rust
// === Private Helpers ===

/// Address of the player the move is expected from, the address of the
/// other player, and the mark to use for the upcoming move.
fun next_player(game: &Game): (address, address, u8) {
    if (game.turn % 2 == 0) {
        (game.x, game.o, MARK_X)
    } else {
        (game.o, game.x, MARK_O)
    }
}

/// Test whether the values at the triple of positions all match each other
/// (and are not all EMPTY).
fun test_triple(game: &Game, x: u8, y: u8, z: u8): bool {
    let x = game.board[x as u64];
    let y = game.board[y as u64];
    let z = game.board[z as u64];

    MARK__ != x && x == y && y == z
}

/// Create a trophy from the current state of the `game`, that indicates
/// that a player won or drew against `other` player.
fun mint_trophy(game: &Game, status: u8, other: address, ctx: &mut TxContext): Trophy {
    Trophy {
        id: object::new(ctx),
        status,
        board: game.board,
        turn: game.turn,
        other,
    }
}

fun mark(game: &Game, row: u8, col: u8): &u8 {
    &game.board[(row * 3 + col) as u64]
}

fun mark_mut(game: &mut Game, row: u8, col: u8): &mut u8 {
    &mut game.board[(row * 3 + col) as u64]
}
```

### `next_player`

- Game object를 입력받아 `turn`의 홀/짝 여부로 다음 턴이 누구 차례인지 판단하고, 해당 턴에 둘 마크를 판단해 알려줍니다.

### `test_triple`

- Game object와 세 개의 위치 인덱스를 받아서, 그 세 칸에 있는 값이 모두 같은지 확인합니다.
- 단, 모두 빈 칸(`MARK__`)이면 안 되도록 조건을 넣습니다.

### `mint_trophy`

- 새로운 Trophy object를 `mint`합니다.

### `mark`와 `mut_mark`

- `mark` → 게임판(board)에서 주어진 (`row`, `col`) 위치의 값을 읽기 전용으로 가져옵니다.
- `mark_mut` → 같은 위치의 값을 수정 가능하게 가져옵니다.
- 두 함수 모두 사실은 1차원 배열(`vector<u8>`)을 2차원 좌표처럼 다룰 수 있게 해주는 도우미 역할을 합니다.
  즉, (row \* 3 + col) 계산을 통해 (행, 열) 좌표를 1차원 인덱스로 바꿉니다: (0,0) → 0, (1,0) → 3, (2,2) → 8.

### 3-8 public 함수 정의

```rust
// === Public Functions ===

/// Create a new game, played by `x` and `o`. The game should be
/// transfered to the address that will administrate the game. If
/// that address is a multi-sig of the two players, its public key
/// should be passed as `admin`.
public fun new(x: address, o: address, admin: vector<u8>, ctx: &mut TxContext): Game {
    let game = Game {
        id: object::new(ctx),
        board: vector[MARK__, MARK__, MARK__, MARK__, MARK__, MARK__, MARK__, MARK__, MARK__],
        turn: 0,
        x,
        o,
        admin,
    };

    let turn = TurnCap {
        id: object::new(ctx),
        game: object::id(&game),
    };

    // X is the first player, so send the capability to them.
    transfer::transfer(turn, x);
    game
}

/// Called by the active player to express their intention to make a move.
/// This consumes the `TurnCap` to prevent a player from making more than
/// one move on their turn.
public fun send_mark(cap: TurnCap, row: u8, col: u8, ctx: &mut TxContext) {
    assert!(row < 3 && col < 3, EInvalidLocation);

    let TurnCap { id, game } = cap;
    id.delete();

    let mark = Mark {
        id: object::new(ctx),
        player: ctx.sender(),
        row,
        col,
    };

    event::emit(MarkSent { game, mark: object::id(&mark) });
    transfer::transfer(mark, game.to_address());
}

/// Called by the admin (who owns the `Game`), to commit a player's
/// intention to make a move. If the game should end, `Trophy`s are sent to
/// the appropriate players, if the game should continue, a new `TurnCap` is
/// sent to the player who should make the next move.
public fun place_mark(game: &mut Game, mark: Receiving<Mark>, ctx: &mut TxContext) {
    assert!(game.ended() == TROPHY_NONE, EAlreadyFinished);

    // Fetch the mark on behalf of the game -- only works if the mark in
    // question was sent to this game.
    let Mark { id, row, col, player } = transfer::receive(&mut game.id, mark);
    id.delete();

    // Confirm that the mark is from the player we expect -- it should not
    // be possible to hit this assertion, because the `Mark`s can only be
    // created by the address that owns the `TurnCap` which cannot be
    // transferred, and is always held by `game.next_player()`.
    let (me, them, sentinel) = game.next_player();
    assert!(me == player, EWrongPlayer);

    if (*mark(game, row, col)== MARK__) {
        *mark_mut(game, row, col) = sentinel;
        game.turn = game.turn + 1;
    };

    // Check win condition -- if there is a winner, send them the trophy,
    // otherwise, create a new turn cap and send that to the next player.
    let end = game.ended();
    if (end == TROPHY_WIN) {
        transfer::transfer(game.mint_trophy(end, them, ctx), me);
        event::emit(GameEnd { game: object::id(game) });
    } else if (end == TROPHY_DRAW) {
        transfer::transfer(game.mint_trophy(end, them, ctx), me);
        transfer::transfer(game.mint_trophy(end, me, ctx), them);
        event::emit(GameEnd { game: object::id(game) });
    } else if (end == TROPHY_NONE) {
        let cap = TurnCap { id: object::new(ctx), game: object::id(game) };
        let (to, _, _) = game.next_player();
        transfer::transfer(cap, to);
    } else {
        abort EInvalidEndState
    }
}

public fun burn(game: Game) {
    assert!(game.ended() != TROPHY_NONE, ENotFinished);
    let Game { id, .. } = game;
    id.delete();
}

/// Test whether the game has reached an end condition or not.
public fun ended(game: &Game): u8 {
    if (// Test rows
        test_triple(game, 0, 1, 2) ||
            test_triple(game, 3, 4, 5) ||
            test_triple(game, 6, 7, 8) ||
            // Test columns
            test_triple(game, 0, 3, 6) ||
            test_triple(game, 1, 4, 7) ||
            test_triple(game, 2, 5, 8) ||
            // Test diagonals
            test_triple(game, 0, 4, 8) ||
            test_triple(game, 2, 4, 6)) {
        TROPHY_WIN
    } else if (game.turn == 9) {
        TROPHY_DRAW
    } else {
        TROPHY_NONE
    }
}
```

### `new` 함수

### Game object 생성

```rust
let game = Game {
    id: object::new(ctx),
    board: vector[MARK__, MARK__, MARK__, MARK__, MARK__, MARK__, MARK__, MARK__, MARK__],
    turn: 0,
    x,
    o,
    admin,
};
```

- `id`: Sui의 고유한 객체 식별자(UID)를 생성
- `board`: 3×3 틱택토 보드, 처음에는 모두 빈 칸(`MARK__`)
- `turn`: 0으로 초기화 → 첫 턴은 X가 둠 (턴은 `next_player` 함수에 의해서 결정)
- `x`, `o`: 두 플레이어 주소 기록
- `admin`: 관리자의 공개키 (게임 종료·검증 등에 사용 가능)

### `TurnCap` 생성

```rust
let turn = TurnCap {
    id: object::new(ctx),
    game: object::id(&game),
};
```

- `TurnCap`은 “누가 지금 차례를 둘 수 있는지”를 나타내는 객체
- `id`: 고유 식별자 부여
- `game`: 방금 만든 Game 객체의 ID 연결

### TurnCap X 플레이어에게 전달, Game object 리턴

```rust
transfer::transfer(turn, x);

game
```

- 생성한 `TurnCap을` `X` 플레이어 주소로 전송합니다.
- 이제 X만이 `place_mark` 같은 함수를 호출해 수를 둘 수 있게 됩니다.

### `send_mark` 함수

### 유효성 검증

```rust
assert!(row < 3 && col < 3, EInvalidLocation);
```

- `row`, `col`이 0,1,2 범위 안에 있는지 체크

### `TurnCap` 소모

```rust
let TurnCap { id, game } = cap;
id.delete();
```

- TurnCap 구조체를 분해해서 `game ID`만 남깁니다.
- `id.delete()`로 TurnCap 객체를 체인에서 제거 → 한 턴에 두 번 두지 못하도록 강제합니다.

### 새 Mark 객체 생성

```rust
let mark = Mark {
    id: object::new(ctx),
    player: ctx.sender(),
    row,
    col,
};
```

- `player`: 트랜잭션을 보낸 주소(= 지금 두는 사람)
- `row`, `col`: 두려는 위치

### `MarkSent` event 발생

```rust
event::emit(MarkSent { game, mark: object::id(&mark) });
```

- Move 표준 라이브러리의 event 모듈 함수로, 전달된 이벤트를 체인에 기록(`log`)합니다.
- 이 이벤트는 상태로 저장되는 건 아니고, 트랜잭션 실행 로그로 남습니다.
- `MarkSent` 구조체 타입의 이벤트 값을 하나 생성합니다.
  - `game`: 이 턴이 속한 게임의 ID
  - `mark`: `object::id(&mark)`: 방금 만든 Mark 객체의 ID (즉, 어떤 마크인지 식별자)

### Mark를 Game object로 전송

```rust
transfer::transfer(mark, game.to_address());
```

- 생성된 Mark를 Game 객체가 관리하는 주소로 전송
- 이후 place_mark 함수에서 이 Mark를 받아서 실제 보드에 반영합니다
- to_address()는 어떤 객체의 `ID`를 그 객체가 속한 주소(`address`)로 변환하는 함수입니다.
