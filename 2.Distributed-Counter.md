# Distributed Counter

이 예제에서는 기본적인 분산 카운터 앱을 만드는 과정을 안내합니다. Sui Move 모듈을 작성하고 이를 React 기반 Sui dApp과 연결하는 끝까지의 전체 흐름을 다룹니다. 이 앱은 사용자가 누구나 증가시킬 수 있는 카운터를 생성할 수 있게 해주며, 단 카운터를 리셋할 수 있는 권한은 소유자에게만 부여됩니다.

**가이드는 두 부분으로 나뉩니다.**

> 1.  스마트 컨트랙트: 카운터 구조체와 로직을 설정하는 Move 코드
> 2.  프론트엔드: 사용자가 카운터 객체를 생성하고, 증가시키며, 리셋할 수 있는 UI

<br>
이번 가이드는 Shared Objects에 대해서 다룹니다. Sui는 Object 중심의 Move 언어를 사용하며, 객체(Object)는 크게 Shared Objects와 Owned Objects로 나뉩니다.

> Shared Objects는 여러 사용자가 동시에 접근할 수 있으며, 전역적으로 공유 가능한 객체입니다.
>
> Owned Objects는 특정 계정이 소유하며, 소유자만이 직접 접근하고 변경할 수 있는 객체입니다.

예를 들어 포커 게임을 생각해볼 수 있습니다.

> Shared Objects: 테이블 위의 포커 덱처럼, 모든 플레이어가 접근하고 카드를 뽑을 수 있는 객체입니다.
>
> Owned Objects: 각 플레이어가 들고 있는 손패처럼, 오직 해당 플레이어만 접근하고 볼 수 있는 객체입니다.

이번 Distributed Counter에서는 Shared Objects를 사용하여 전역적으로 접근 가능한 카운터 객체(Counter objects)를 생성하고, 누구나 증가시킬 수 있도록 구현합니다.

## 1단계: 프로젝트 폴더 생성

시스템에서 새로운 폴더를 생성합니다.

```bash
mkdir distributed-counter
```

이 폴더는 프로젝트의 모든 파일을 담는 최상위 폴더입니다.
원하는 다른 이름으로 바꿔도 되지만, 이후 가이드에서는 이 구조를 기준으로 설명합니다.

## 2단계: Move 디렉토리 생성

```bash
mkdir -p ./move/counter/sources
```

`sources` 폴더에 move 코드가 작성될 것입니다.

## 3단계: Smart Contracts 작성

### 3-1: toml 파일 작성

스마트 컨트랙트를 작성하기 시작하려면, distributed-counter/move/counter 안에 `Move.toml` 파일을 생성하고, 다음 코드를 복사하여 붙여넣습니다.

```bash
[package]
name = "counter"
version = "0.0.1"
edition = "2024.beta"

[dependencies]
Sui = { git = "https://github.com/MystenLabs/sui.git", subdir = "crates/sui-framework/packages/sui-framework", rev = "framework/testnet" }

[addresses]
counter = "0x0"
```

`Move.toml`은 Move 패키지의 매니페스트 파일로, Move 모듈을 구성하고 관리하는 정보를 담고 있습니다.

### 1. [package]

패키지 자체의 기본 정보를 정의하는 필드입니다.

| 필드      | 설명                         | 예시 값       |
| --------- | ---------------------------- | ------------- |
| `name`    | 패키지 이름                  | `"counter"`   |
| `version` | 패키지 버전                  | `"0.0.1"`     |
| `edition` | Move 언어 버전/패키지 에디션 | `"2024.beta"` |

> 💡 **간단 설명**: 이 패키지가 어떤 이름과 버전으로 존재하는지, 어떤 Move 에디션을 사용하는지 알려주는 설정입니다.

### 2. [dependencies]

패키지가 의존하는 다른 Move 패키지나 라이브러리를 선언하는 필드입니다. 예제에서는 Sui 패키지를 Git 리포지토리에서 가져오도록 설정합니다.

| 필드     | 설명                             | 예시 값                                         |
| -------- | -------------------------------- | ----------------------------------------------- |
| `git`    | 패키지 Git URL                   | `"https://github.com/MystenLabs/sui.git"`       |
| `subdir` | 해당 리포지토리 내의 패키지 경로 | `"crates/sui-framework/packages/sui-framework"` |
| `rev`    | 사용할 브랜치나 커밋             | `"framework/testnet"`                           |

> 💡 **간단 설명**: 내 패키지가 다른 패키지(Sui 프레임워크)를 필요로 한다고 알려주는 설정입니다. `Distributed Counter`에서는 `transfer::share_object`를 사용하기 위해 Sui 프레임워크를 추가했습니다.

### 3. [addresses]

Move 패키지에서 사용할 전역 주소(Address) 매핑을 정의하는 필드입니다.

| 설정              | 설명                              |
| ----------------- | --------------------------------- |
| `counter = "0x0"` | counter 모듈이 배포될 주소를 지정 |

> ⚠️ **참고**: 이후 배포 시 실제 계정 주소로 변경할 수 있습니다.

> 💡 **간단 설명**: Move 모듈이 블록체인 상 어디에 위치할지 지정하는 설정입니다.

### 3-2 `counter.move` 파일 생성 및 `module` 정의

distributed-counter/move/counter/sources 안에 `counter.move` 파일을 생성합니다.
파일 안에 아래 코드를 작성합니다.

```rust
module counter::counter;
```

`counter::counter는` 패키지 이름(counter)과 모듈 이름(counter)을 `::`로 구분한 네임스페이스입니다.

- 첫 번째 counter: 패키지 이름 (Move.toml의 `[package] name = "counter"`)

- 두 번째 counter: 모듈 이름, 이 안에 스마트 컨트랙트 로직을 작성

즉, “이 패키지 안에 counter라는 모듈을 만들겠다”라는 선언입니다.

> 패키지(Package) <br>
> 패키지 = Move 모듈들의 묶음 + 메타데이터
>
> Move.toml 파일로 정의하며, 하나의 패키지 안에는 여러 모듈을 포함할 수 있습니다.
>
> 패키지는 배포 단위입니다. 블록체인에 배포할 때 패키지 단위로 빌드 및 배포합니다.
>
> 예시: counter 패키지 → Counter 모듈이 들어 있는 패키지

> 모듈(Module) <br>
> 모듈 = 스마트 컨트랙트 또는 기능 단위 코드
>
> 패키지 안에서 정의하며, struct와 함수들을 포함합니다.
>
> 모듈 안에서 정의한 함수와 구조체는 다른 모듈이나 외부에서 불러서 사용할 수 있습니다.
>
> 예시: counter::counter 모듈 → Counter struct, increment(), reset() 함수 포함

### 3-3 `Counter` struct 생성

```rust
public struct Counter has key {
  id: UID,
  owner: address,
  value: u64
}
```

`Counter` 타입은 그 소유자의 주소(`owner`), 현재 상태(`value`), 그리고 자신의 아이디(`id`)을 저장한다.

### Sui의 객체에서의`has key`와 `id`

> - `has key`: 이 구조체는 블록체인에서 고유하게 식별 가능한 객체임을 의미
>
> - `id`: `UID`: 객체마다 중복 없는 고유 ID를 가지고 있음 → 블록체인이 객체를 추적 가능

Move에서는 모든 자산과 데이터가 객체(Object) 단위로 소유권과 상태를 명확히 관리되도록 설계되어 있습니다. Sui에서 객체는 `has key`와 `UID` 덕분에 블록체인 상에서 누가 소유하고 있는지, 그리고 현재 값이 무엇인지 정확히 관리할 수 있습니다. 이는 소유자 권한 관리, 상태 추적, 동시성 처리, 데이터 일관성을 보장하는 데 필수적입니다.

### 3-4 `Counter`의 로직 작성

```rust
public fun create(ctx: &mut TxContext) {
  transfer::share_object(Counter {
    id: object::new(ctx),
    owner: ctx.sender(),
    value: 0
  })
}

public fun increment(counter: &mut Counter) {
  counter.value = counter.value + 1;
}

public fun set_value(counter: &mut Counter, value: u64, ctx: &TxContext) {
  assert!(counter.owner == ctx.sender(), 0);
  counter.value = value;
}
```

> `public`: 다른 모듈이나 사용자가 호출 가능
>
> `&mut`: 원본을 그대로 빌려서 읽고 쓸 수 있는 참조로, 함수 안에서 값을 직접 수정할 때 사용합니다. 즉, 객체를 생성하거나 상태를 바꿀 때 쓰면 됩니다.

### `Create`함수

```rust
public fun create(ctx: &mut TxContext)

```

**`ctx: &mut TxContext`: 트랜잭션 컨텍스트를 받아옵니다**

- Move/Sui에서는 트랜잭션이 누가 보냈는지, 어떤 자원이 사용되는지를 TxContext가 관리합니다.
- `&mut` → 함수 안에서 컨텍스트를 수정할 수 있습니다. (예: 새 객체 생성)

```rust
transfer::share_object(Counter { ... })
```

**`share_object` → Shared Object로 등록합니다.**

- Shared Object는 모든 사람이 접근 가능합니다.
- Distributed Counter에서는 여러 사용자가 increment 가능하게 만드는 핵심입니다.

```rust
Counter {
    id: object::new(ctx),
    owner: ctx.sender(),
    value: 0
  }
```

**`object::new(ctx)` → 새 UID를 생성합니다.**

- Sui에서 `has key` 객체를 만들 때 고유 ID를 만들어서 블록체인에 등록합니다.

**`ctx.sender()` → 이 트랜잭션을 실행한 보낸 사람의 주소**

- `Counter` 객체를 누가 소유하는지 `owner`로 지정합니다.

**`value: 0`**

- `Counter`의 초기 상태 값을 0으로 설정합니다.

### `increment` 함수

```rust
public fun increment(counter: &mut Counter)
```

**`counter: &mut Counter`: Counter 객체를 직접 수정할 수 있는 참조로 전달합니다.**

- Move에서는 값을 복사하지 않고 원본을 수정하므로, 함수에서 객체를 바꾸면 실제 블록체인 상의 상태가 바로 변경됩니다.

```rust
counter.value = counter.value + 1;
```

**`Counter` 객체 안의 현재 값을 `1` 증가시킵니다.**

### `set_value` 함수

```rust
public fun set_value(counter: &mut Counter, value: u64, ctx: &TxContext)
```

**`counter: &mut Counter`: Counter 객체의 원본을 직접 수정합니다.**

**`ctx: &TxContext`: 트랜잭션 정보를 전달합니다. (누가 호출했는지 확인 가능)**

```rust
assert!(counter.owner == ctx.sender(), 0);
```

**`counter.owner == ctx.sender()` → 이 Counter를 만든 사람과 호출자가 같은지 확인합니다.**

- assert! → 뒤의 조건이 참이 아니면 트랜잭션 실패합니다.
- 0 → 실패 시 반환할 에러 코드입니다.

> 즉, Counter의 값은 소유자만 바꿀 수 있습니다.

```rust
counter.value = value;
```

**전달받은 `value`로 Counter 값을 직접 변경합니다.**

### 3-5 전체 코드

최종 `module`은 다음과 같습니다.

```rust
module counter::counter;

public struct Counter has key {
    id: UID,
    owner: address,
    value: u64
}

public fun create(ctx: &mut TxContext) {
    transfer::share_object(Counter {
        id: object::new(ctx),
        owner: ctx.sender(),
        value: 0
    })
}

public fun increment(counter: &mut Counter) {
    counter.value = counter.value + 1;
}

public fun set_value(counter: &mut Counter, value: u64, ctx: &TxContext) {
    assert!(counter.owner == ctx.sender(), 0);
    counter.value = value;
}
```

## 4단계 Package 배포

### 4-1 Sui Client CLI 설치 확인

Package를 배포하기 전에, Sui Client CLI를 설정되어 있어야 합니다.
프로젝트 루트 디렉토리에서 터미널을 열고 다음 명령을 실행하세요:

```bash
sui client
```

**만약 다음과 같은 응답을 받으면, 1.sui-cli-installation.md를 참고해서 Sui Client CLI를 설정하시기 바랍니다.**

```bash
Config file ["<FILE-PATH>/.sui/sui_config/client.yaml"] doesn't exist, do you want to connect to a Sui full node server [y/N]?
```

### 4-2 network `testnet`으로 설정

**예제에서는 `testnet`을 사용합니다.**

```bash
sui client switch --env testnet
```

### 4-3 가스비로 사용될 sui 토큰 받기

**배포를 하기 위해서는 가스비로 사용할 Testnet Sui 토큰이 필요합니다.**

**먼저 sui client에 사용되는 계정의 주소를 확인합니다.**

```bash
sui client active-address
```

위의 명령어를 통해 출력된 값이 현재 client 사용자의 주소입니다.

아래 Sui faucet 사이트에 방문하여 계정 주소를 입력하고 `Request Testnet SUI 버튼을 누릅니다.

```plain text
https://faucet.sui.io/
```

아래 명령어를 입력하여 `balance`가 증가한 것을 확인합니다.

```bash
sui client balance
```

### 4-4 Package 배포

git을 사용할 경우 root 디렉토리에 `.gitignore` 파일을 생성후 아래와 같이 작성합니다.

```plain text
move/counter/build/
```

다음 명령어를 터미널에 입력하여 결과를 확인하세요. 이때 명령어는 `Move.toml`파일이 있는 같은 디렉토리에서 실행되어야 합니다.

```bash
sui client publish
```

> `Request rejected 429` 에러는 `Too Many Requests.` 에러로 발생시 배포 명령을 다시 실행해야 합니다.
>
> `Could not determine the gas budget. Error: Request rejected 429` 에러가 발생할 경우, `sui client publish` 명령어 뒤에 `--gas-budget 20000000` 옵션을 추가하여 지불할 가스 비용을 명시적으로 지정해줍니다.

이 명령을 실행하면 아래와 같이 `packageID` 값이 출력되며, 이후에 package를 사용하기 위해 반드시 이 값을 저장해 두어야 합니다.

```bash
╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Object Changes                                                                                   │
├──────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Created Objects:                                                                                 │
│  ┌──                                                                                             │
│  │ ObjectID: 0x5f460935265e2c7727a72db1dc2b9ac0b83b1554f6115ce0d411af1de6647aa6                  │
│  │ Sender: 0xd43008f2255d346b29a5a87b64a8f991373684a4cd73fe2ad57c31584bf68a0b                    │
│  │ Owner: Account Address ( 0xd43008f2255d346b29a5a87b64a8f991373684a4cd73fe2ad57c31584bf68a0b ) │
│  │ ObjectType: 0x2::package::UpgradeCap                                                          │
│  │ Version: 349167823                                                                            │
│  │ Digest: 8PC3Nay25qXP9icSK6sBLRxQZ7PGNYBZCMBY9Zj1WqLZ                                          │
│  └──                                                                                             │
│ Mutated Objects:                                                                                 │
│  ┌──                                                                                             │
│  │ ObjectID: 0xb57fb3a51ba2fc5d8eab8708779362eb49f54a6ceb7f0b4848e80c2062702afa                  │
│  │ Sender: 0xd43008f2255d346b29a5a87b64a8f991373684a4cd73fe2ad57c31584bf68a0b                    │
│  │ Owner: Account Address ( 0xd43008f2255d346b29a5a87b64a8f991373684a4cd73fe2ad57c31584bf68a0b ) │
│  │ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                    │
│  │ Version: 349167823                                                                            │
│  │ Digest: FGzs8gSsEGdhzsiNRb5Absf9u71coubptSGpsQUGgMh1                                          │
│  └──                                                                                             │
│ Published Objects:                                                                               │
│  ┌──                                                                                             │
│  │ PackageID: 0xad6ef04f3fcca07008be1bcc26a718c674d1ad494ef35ff3d2d20f4a9ecdab8e                 │
│  │ Version: 1                                                                                    │
│  │ Digest: 4r8tVf5a9StT28dxaQZty8u8Gxw4SP1DqVUvkQeg8Xto                                          │
│  │ Modules: counter                                                                              │
│  └──                                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────╯
```

배포 후 터미널의 Object Changes에는 3개의 Object에 대한 트랜잭션 결과 요약이 나타납니다.

- `Created Objects` → 새로 만들어진 객체 (예: UpgradeCap)
- `Mutated Objects` → 기존 객체가 수정됨 (예: Sui 코인 수량 변경)
- `Published Objects` → Move 패키지 자체가 배포됨
  <br><br>

1. `Created Objects`
   - `UpgradeCap` 객체가 생성
   - `UpgradeCap`은 “이 패키지를 업그레이드할 수 있는 권한 증명서”
   - 즉, UpgradeCap을 가진 계정만 패키지를 재배포하거나 업그레이드가 가능합니다.
2. `Mutated Objects`
   - Mutated Objects는 이미 존재하는 객체가 변경된 경우 표시되며, 예시에서는 Sui 코인 객체가 업데이트되었습니다.
   - 즉, Sui 코인 수량의 증가/감소, 거래 등의 결과가 표시되었습니다.
3. `Published Objects`
   - 배포된 `Counter Package`의 정보를 확인할 수 있습니다.
   - 프론트엔드와의 연결을 위해 Package의 고유 아이디인 `PackageID`를 따로 저장해둡니다.
     <br><br>

**`Object Changes`의 요소들**

- `ObjectID`: Sui 블록체인 상에서 이 객체의 고유 식별자.
- `Sender`: 이 객체를 생성한 계정 주소.
- `Owner`: 객체를 소유하는 계정(권한 있는 계정). 보통 Sender와 동일.
- `ObjectType`: 객체의 타입
- `Version`: 객체의 버전, 객체가 수정될 때마다 증가.
- `Digest`: 객체 내용의 해시값, 무결성 확인용.

## 5단계 프론트엔드 생성

### 5-1 프론트엔드 scaffold 생성

아래는 Sui Dapp을 생성하기 위한 기본 틀을 제공해주는 Scaffold를 생성하는 명령어입니다. `move` 폴더와 같은 루트 디렉토리에 생성해줍니다.

```bash
pnpm create @mysten/dapp --template counter-dapp
```

### 5-2 필요한 dependencies 설치

이 앱은 아이콘 표시를 위해 `react-spinners` 패키지를 사용합니다.

```bash
pnpm add react-spinners
```

git을 사용할 경우 `.gitignore` 파일에 다음을 추가합니다.

```plain text
node_modules/
```
